Below is a **complete, production-style API design in Python** that:

* Issues API keys (like OpenAI)
* Authenticates requests
* Tracks usage
* Enforces rate limits
* Supports **billing plans & quotas**
* Is ready to deploy

This is **not toy code** — it’s how real APIs are built.

---

# Tech Stack (recommended)

* **FastAPI** – modern, fast, async
* **PostgreSQL** – persistent storage
* **SQLAlchemy** – ORM
* **Stripe** – billing
* **Redis** – rate limiting (optional but recommended)
* **Uvicorn** – server

---

# Architecture Overview

```
Client
  └── API Key → FastAPI
        ├── Auth Middleware
        ├── Usage Tracker
        ├── Rate Limiter
        ├── Billing Enforcement
        └── Your API Logic
```

---

# 1. Install Dependencies

```bash
pip install fastapi uvicorn sqlalchemy psycopg2-binary
pip install python-dotenv stripe slowapi redis
pip install passlib[bcrypt]
```

---

# 2. Database Models

### `database.py`

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = "postgresql://user:password@localhost/apidb"

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()
```

---

### `models.py`

```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.sql import func
from database import Base

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True)
    stripe_customer_id = Column(String)

class APIKey(Base):
    __tablename__ = "api_keys"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    key_hash = Column(String, unique=True)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, server_default=func.now())

class Usage(Base):
    __tablename__ = "usage"
    id = Column(Integer, primary_key=True)
    api_key_id = Column(Integer)
    requests = Column(Integer, default=0)
    month = Column(String)  # YYYY-MM
```

---

# 3. API Key Generation & Hashing

### `security.py`

```python
import secrets
import hashlib

def generate_api_key():
    return "sk_live_" + secrets.token_hex(32)

def hash_key(key: str):
    return hashlib.sha256(key.encode()).hexdigest()
```

---

# 4. Authentication Middleware

### `auth.py`

```python
from fastapi import Header, HTTPException, Depends
from sqlalchemy.orm import Session
from database import SessionLocal
from security import hash_key
from models import APIKey

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def api_key_auth(x_api_key: str = Header(None), db: Session = Depends(get_db)):
    if not x_api_key:
        raise HTTPException(401, "API key required")

    hashed = hash_key(x_api_key)
    key = db.query(APIKey).filter_by(
        key_hash=hashed, is_active=True
    ).first()

    if not key:
        raise HTTPException(403, "Invalid API key")

    return key
```

---

# 5. Usage Tracking & Quotas

### `usage.py`

```python
from datetime import datetime
from models import Usage

FREE_PLAN_LIMIT = 1000
PRO_PLAN_LIMIT = 100_000

def track_usage(db, api_key_id, plan):
    month = datetime.utcnow().strftime("%Y-%m")

    usage = db.query(Usage).filter_by(
        api_key_id=api_key_id, month=month
    ).first()

    if not usage:
        usage = Usage(api_key_id=api_key_id, month=month, requests=0)
        db.add(usage)

    limit = FREE_PLAN_LIMIT if plan == "free" else PRO_PLAN_LIMIT

    if usage.requests >= limit:
        raise Exception("Quota exceeded")

    usage.requests += 1
    db.commit()
```

---

# 6. Rate Limiting (Redis-based)

```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
```

Apply per route:

```python
@limiter.limit("10/second")
```

---

# 7. Stripe Billing Setup

### `billing.py`

```python
import stripe
stripe.api_key = "sk_test_xxx"

def create_customer(email):
    return stripe.Customer.create(email=email)

def create_subscription(customer_id, price_id):
    return stripe.Subscription.create(
        customer=customer_id,
        items=[{"price": price_id}]
    )
```

---

# 8. Main API App

### `main.py`

```python
from fastapi import FastAPI, Depends
from auth import api_key_auth
from usage import track_usage

app = FastAPI()

@app.get("/v1/hello")
def hello(api_key=Depends(api_key_auth)):
    track_usage(db=api_key._sa_instance_state.session,
                api_key_id=api_key.id,
                plan="free")

    return {"message": "Hello from your API!"}
```

---

# 9. Create API Keys Endpoint (Dashboard-style)

```python
@app.post("/dashboard/create-key")
def create_key(user_id: int, db=Depends(get_db)):
    raw_key = generate_api_key()
    hashed = hash_key(raw_key)

    key = APIKey(user_id=user_id, key_hash=hashed)
    db.add(key)
    db.commit()

    return {"api_key": raw_key}  # shown ONCE
```

---

# 10. Example Client Request

```bash
curl https://yourapi.com/v1/hello \
  -H "x-api-key: sk_live_xxxxx"
```

---

# 11. Deployment

* **Railway / Fly.io / AWS ECS**
* **Postgres managed DB**
* **Redis for rate limiting**
* **HTTPS only**
* **Environment variables**

---

# What You Have Now

✅ OpenAI-style API keys
✅ Authentication middleware
✅ Monthly usage quotas
✅ Rate limiting
✅ Stripe billing
✅ Scalable architecture

---

## Want next-level features?

I can add:

* Token-based billing (like OpenAI)
* Per-endpoint pricing
* Usage dashboard UI
* Invoice generation
* Webhooks for Stripe events
* Team/org API keys

Tell me **how real you want this** (learning, startup, SaaS) and I’ll tailor it.
